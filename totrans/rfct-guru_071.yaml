- en: Replace Type Code with State/Strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://refactoringguru.cn/replace-type-code-with-state-strategy](https://refactoringguru.cn/replace-type-code-with-state-strategy)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**What''s type code?** Type code occurs when, instead of a separate data type,
    you have a set of numbers or strings that form a list of allowable values for
    some entity. Often these specific numbers and strings are given understandable
    names via constants, which is the reason for why such type code is encountered
    so much.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You have a coded type that affects behavior but you can't use subclasses to
    get rid of it.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Replace type code with a state object. If it's necessary to replace a field
    value with type code, another state object is "plugged in".
  prefs: []
  type: TYPE_NORMAL
- en: Before![Replace Type Code with State-Strategy - Before](../Images/6414214585273f341380c0154622f4ec.png)After![Replace
    Type Code with State-Strategy - After](../Images/d294761863153e227234b75ca0d43964.png)
  prefs: []
  type: TYPE_NORMAL
- en: Why Refactor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You have type code and it affects the behavior of a class, therefore we can't
    use [Replace Type Code with Class](/replace-type-code-with-class).
  prefs: []
  type: TYPE_NORMAL
- en: Type code affects the behavior of a class but we can't create subclasses for
    the coded type due to the existing class hierarchy or other reasons. Thus means
    that we can't apply [Replace Type Code with Subclasses](/replace-type-code-with-subclasses).
  prefs: []
  type: TYPE_NORMAL
- en: Benefits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This refactoring technique is a way out of situations when a field with a coded
    type changes its value during the object's lifetime. In this case, replacement
    of the value is made via replacement of the state object to which the original
    class refers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need to add a new value of a coded type, all you need to do is to add
    a new state subclass without altering the existing code (cf. the *Open/Closed
    Principle*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawbacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have a simple case of type code but you use this refactoring technique
    anyway, you will have many extra (and unneeded) classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Good to Know
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Implementation of this refactoring technique can make use of one of two design
    patterns: **State** or **Strategy**. Implementation is the same no matter which
    pattern you choose. So which pattern should you pick in a particular situation?'
  prefs: []
  type: TYPE_NORMAL
- en: If you're trying to split a conditional that controls the selection of algorithms,
    use Strategy.
  prefs: []
  type: TYPE_NORMAL
- en: But if each value of the coded type is responsible not only for selecting an
    algorithm but for the whole condition of the class, class state, field values,
    and many other actions, State is better for the job.
  prefs: []
  type: TYPE_NORMAL
- en: How to Refactor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use [Self Encapsulate Field](/self-encapsulate-field) to create a getter for
    the field that contains type code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new class and give it an understandable name that fits the purpose
    of the type code. This class will be playing the role of *state* (or *strategy*).
    In it, create an abstract coded field getter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create subclasses of the state class for each value of the coded type. In each
    subclass, redefine the getter of the coded field so that it returns the corresponding
    value of the coded type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the abstract state class, create a static factory method that accepts the
    value of the coded type as a parameter. Depending on this parameter, the factory
    method will create objects of various states. For this, in its code create a large
    conditional; it'll be the only one when refactoring is complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the original class, change the type of the coded field to the state class.
    In the field's setter, call the factory state method for getting new state objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now you can start to move the fields and methods from the superclass to the
    corresponding state subclasses (using [Push Down Field](/push-down-field) and
    [Push Down Method](/push-down-method)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When everything moveable has been moved, use [Replace Conditional with Polymorphism](/replace-conditional-with-polymorphism)
    in order to get rid of conditionals that use type code once and for all.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[</images/refactoring/banners/tired-of-reading-banner-1x.mp4?id=7fa8f9682afda143c2a491c6ab1c1e56>'
  prefs: []
  type: TYPE_NORMAL
- en: </images/refactoring/banners/tired-of-reading-banner.png?id=1721d160ff9c84cbf8912f5d282e2bb4>
  prefs: []
  type: TYPE_NORMAL
- en: Your browser does not support HTML video.](/refactoring/course)
  prefs: []
  type: TYPE_NORMAL
- en: Tired of reading?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No wonder, it takes 7 hours to read all of the text we have here.
  prefs: []
  type: TYPE_NORMAL
- en: Try our interactive course on refactoring. It offers a less tedious approach
    to learning new stuff.
  prefs: []
  type: TYPE_NORMAL
- en: '[*Let''s see…*](/refactoring/course)'
  prefs: []
  type: TYPE_NORMAL
