- en: Form Template Method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://refactoringguru.cn/form-template-method](https://refactoringguru.cn/form-template-method)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Your subclasses implement algorithms that contain similar steps in the same
    order.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Move the algorithm structure and identical steps to a superclass, and leave
    implementation of the different steps in the subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Before![Form Template Method - Before](../Images/88924c2c42cf0cd644fe5e19b6f9c0ea.png)After![Form
    Template Method - After](../Images/ed1cf17084697b19489c46fa72322139.png)
  prefs: []
  type: TYPE_NORMAL
- en: Why Refactor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Subclasses are developed in parallel, sometimes by different people, which leads
    to code duplication, errors, and difficulties in code maintenance, since each
    change must be made in all subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Code duplication doesn't always refer to cases of simple copy/paste. Often duplication
    occurs at a higher level, such as when you have a method for sorting numbers and
    a method for sorting object collections that are differentiated only by the comparison
    of elements. Creating a template method eliminates this duplication by merging
    the shared algorithm steps in a superclass and leaving just the differences in
    the subclasses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forming a template method is an example of the *Open/Closed Principle* in action.
    When a new algorithm version appears, you need only to create a new subclass;
    no changes to existing code are required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to Refactor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Split algorithms in the subclasses into their constituent parts described in
    separate methods. [Extract Method](/extract-method) can help with this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The resulting methods that are identical for all subclasses can be moved to
    a superclass via [Pull Up Method](/pull-up-method).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The non-similar methods can be given consistent names via [Rename Method](/rename-method).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the signatures of non-similar methods to a superclass as abstract ones
    by using [Pull Up Method](/pull-up-method). Leave their implementations in the
    subclasses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And finally, pull up the main method of the algorithm to the superclass. Now
    it should work with the method steps described in the superclass, both real and
    abstract.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[</images/refactoring/banners/tired-of-reading-banner-1x.mp4?id=7fa8f9682afda143c2a491c6ab1c1e56>'
  prefs: []
  type: TYPE_NORMAL
- en: </images/refactoring/banners/tired-of-reading-banner.png?id=1721d160ff9c84cbf8912f5d282e2bb4>
  prefs: []
  type: TYPE_NORMAL
- en: Your browser does not support HTML video.](/refactoring/course)
  prefs: []
  type: TYPE_NORMAL
- en: Tired of reading?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No wonder, it takes 7 hours to read all of the text we have here.
  prefs: []
  type: TYPE_NORMAL
- en: Try our interactive course on refactoring. It offers a less tedious approach
    to learning new stuff.
  prefs: []
  type: TYPE_NORMAL
- en: '[*Let''s see…*](/refactoring/course)'
  prefs: []
  type: TYPE_NORMAL
