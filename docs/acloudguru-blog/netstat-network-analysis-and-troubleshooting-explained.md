# Linux netstat 命令:分析和故障排除讲解 Linux netstat 命令:分析和故障排除讲解

> 原文：<https://acloudguru.com/blog/engineering/netstat-network-analysis-and-troubleshooting-explained>

netstat 命令为您提供了一套工具来回答“我的网络上到底发生了什么？”当事情出错的时候。然而，为了能够在这种场合下有效地使用它，你可能想现在就了解它是如何工作的，所以你要做好准备。此外，更好地了解你的人际网络也无妨。

请继续阅读，了解 netstat 到底是什么，您可以用它来做什么，以及它如何帮助您解决问题和了解您的网络。

* * *

## 加速您的职业发展

[从 ACG 开始](https://acloudguru.com/pricing)通过 AWS、Microsoft Azure、Google Cloud 等领域的课程和实际动手实验室改变你的职业生涯。

* * *

## 为什么要使用 Linux netstat 命令？

netstat 命令并不真正做独特的事情。它可以打印网络统计数据，但是 ifconfig 也可以这样做。它可以打印路由表，但 route 也可以这样做。它可以打印开放连接，但 lsof 可以做到这一点，甚至更多。那么为什么要使用 netstat 呢？有两个主要原因:

1.  netstat 在一个命令中捆绑了一些常用的网络分析操作
2.  netstat 是多平台的

没错，netstat 在 Windows 和 Mac 上都有，语法也差不多。一次学会，随处使用。当您对运行不同操作系统的机器进行网络故障排除时，这非常方便。所以，事不宜迟，让我们深入了解 netstat 的主要功能。

## 打印网络连接

使用 netstat，您可以列出您的机器和其他机器之间当前存在的网络连接，以及侦听来自其他机器的连接的套接字。它可以告诉你哪些程序正在你的网络上运行。这里有一个例子:

> >sudo netstat-apA inet活跃互联网连接(服务器和已建立) Proto Recv-Q Send-Q 本地地址国外地址状态 PID/程序名TCP 0 0 localhost:46178 *:* list EN 2484/Google talk plugTCP 0 localhost:41093 *:* list EN 2484/Google talk plugTCP 0 *:ssh *:* list EN 1894 list EN 1366/DropboxTCP 0 0 trafalgar . local:54744 wi-in-f 17.1 e100 . n:https ESTABLISHED 1792/FirefoxTCP 0 localhost:41093 localhost:45741 ESTABLISHED 2484/Google talk plugTCP 38 0 trafalgar . local:32808v-client-5b . sjc . d:https CLOSE _ 中 1366/DropboxUDP 0 0 *:49678 *:* 642/avahi-daemon:rUDP 0 0 *:bootpc *:* 932/dhclient 3UDP 0 0 *:bootpc *:* 1854/dhclient 3UDP 0 *:17500 *:* 1366/DropboxUDP 0

这是大量的信息！让我解释一下，从这些列代表什么开始。

*   **“Proto”列**告诉我们列出的套接字是 TCP 还是 UDP。那些是网络协议。TCP 建立了可靠的连接，但是如果网络质量不好，速度会大大降低。UDP 速度很快，但可能会丢失一些数据包或以错误的顺序传递它们。TCP 连接用于浏览网页和下载文件。UDP 连接被某些快节奏的计算机游戏使用，有时也被实时流使用。
*   **“Recv-Q”和“Send-Q”列**告诉我们该套接字的队列中有多少数据在等待读取(Recv-Q)或发送(Send-Q)。简而言之:如果这是 0，一切正常。如果任何地方有非零值，就可能有麻烦。如果仔细观察这个例子，您会看到两个套接字有一个 Recv-Q，其中有 38 个未读字节。一旦我们知道了其他列的含义，我们将研究这些联系。
*   **“本地地址”和“外地地址”列**告知列出的套接字连接到哪些主机和端口。本地端总是在运行 netstat 的计算机上(在本例中，该计算机称为“Trafalgar”)，而外部端是关于另一台计算机(可能在本地网络中的某个地方，也可能在互联网上的某个地方)。如果您仔细观察这个例子，您会看到两个套接字将 localhost 作为外部地址。很奇怪，对吧？可以说，这意味着计算机正在通过网络与自己对话。一旦我们知道了所有列的含义，我们将研究它的含义。
*   **“状态”栏**告知列出的插座处于何种状态。TCP 协议定义了状态，包括“LISTEN”(等待外部计算机联系我们)和“ESTABLISHED”(准备好通信)。其中最奇怪的是两个套接字显示的“关闭等待”状态。这意味着外部或远程机器已经关闭了连接，但是本地程序不知何故没有跟着关闭。请注意，两个“关闭等待”套接字也是 Recv-Q 中有 38 个未读字节的套接字。奇怪的状态和非空队列经常一起出现。
*   **“pid/程序名”列**告诉我们哪个 PID 拥有列出的套接字，以及在具有该 PID 的进程中运行的程序的名称。因此，您可以看到哪些程序正在使用网络，以及它们正在连接到谁。

那么如何解读这个输出的一行呢？我们来看看以“火狐”结尾的那一行。Firefox 在为安全 HTTP 连接预留的端口(顺便说一下是 443)上连接到外来地址 wi-in-f 17.1 e 100 . n[某个东西]。使用-W 选项(sudo netstat -ap **W** A inet)，完整的外国地址显示为 wi-in-f17.1e100.net，恰好属于谷歌。这个连接可能是存在的，因为当我运行这个命令时，Gmail 是在一个标签页中打开的。这里没问题。

在查看列含义时，我们遇到了一些奇怪的连接。首先，有两个 Recv-Q 为 38(实际上应该是 0)且处于“关闭等待”状态的连接。最后一列告诉我们，这些套接字都属于 Dropbox，它还有一些其他连接和一个侦听套接字，看起来情况更好。不知何故，Dropbox 似乎在“泄漏”插座，或者至少让它们悬着。外部机器已经关闭了两个连接，但是本地 Dropbox 进程没有关闭它们，这意味着套接字占用的资源没有被释放。这可能是 Dropbox 部分的一些草率编程，但只要它只留下两个套接字，就不是什么大问题。

如果你有一个程序生成了很多这样的套接字，你可能想把它报告给程序的创建者，并且可能定期重启程序来摆脱混乱。

我们遇到的另一个奇怪的事情是，两个套接字都有 localhost 作为外来地址，这意味着这台计算机和它本身之间有一个网络连接。然而，PID/程序名称列告诉我们有两个不同的程序以这种方式通信，即 Google Talk 插件和 plugin-container，这是 Firefox 用于运行插件的容器程序。换句话说，Google Talk 插件使用 TCP 网络在同一台计算机上运行的独立部分和 Firefox 插件部分之间进行通信(注意本地端口号和外部端口号是如何匹配的)。

这种使用网络功能的方式不常使用，但在这种情况下很有意义。因为联网是跨平台统一的(Linux、Windows 和 Mac 都以相同的方式进行)，所以在这里使用它为 Google Talk 插件提供了一种在各部分之间进行通信的可移植方式。

现在，让我告诉您，要充分利用 netstat 的输出，需要对网络以及什么程序应该和不应该使用您的网络有一些透彻的了解。然而，如果你没有这方面的知识，你至少还可以通过在互联网上搜索你不知道的程序并阅读它们来决定它们是否应该存在，从而知道哪里出了问题。为了帮助你更好地理解正在发生的事情，这里有一些提示:

*   如果外部地址是*:*(对于 TCP 套接字，状态是 LISTEN)，套接字通常等待某个远程主机发送第一个数据。典型的例子有:sshd(等待某人打开 ssh 连接)、apache(等待某人请求网页)、cupsd(等待某人发送打印作业)和 dhclient(等待 DHCP 服务器发送，例如，续订租约)。
*   当连接到外部主机时，您计算机上的程序通常不关心哪个本地端口用于连接。这就是为什么本地端的端口通常不被识别和转换成像“https”或“www”这样的协议；它实际上是从一系列未预留的端口中挑选出来的，以避免与其他协议混淆。这种端口号的示例(来自上面的输出示例):54744、32808 和 34354。

在转到 netstat 的下一种输出类型之前，让我解释一下示例中使用的选项。首先，-a 告诉 netstat 显示所有套接字，包括监听和非监听。接下来，-p 告诉 netstat 显示 PID/Program name 列，这对于判断一个套接字是否应该存在非常有帮助。

最后，“-A inet”告诉 netstat 只显示 TCP/UDP 套接字。如果没有这个选项，输出通常会充斥着 Unix 套接字，从网络的角度来看，这没什么意思。注意，在 Windows 上，“-A inet”可以直接省略，-p 应该替换为-o，在 Mac 上，没有-p 的对等词，“-A inet”变成了“-f inet”。如果你需要知道 Mac 上的程序名/PID，使用“lsof -i”。

## 打印路由表

除了活动套接字之外，netstat 还可以列出计算机路由表中的当前条目。在网络世界中，路由意味着决定将带有特定目的地的数据包发送到哪里。再举一个例子:

> > netstat -rKernel IP 路由表目的网关 Genmask 标志 MSS 窗口 irtt iface 192 . 168 . 1 . 0 * 255 . 255 . 255 . 0 U 0 0 eth 0 link-local * 255 . 255 . 0 . 0 U 0 0 eth 0 default smoothwall 0 . 0 . 0 . 0 UG 0 0 eth 0

正如您可能已经猜到的那样，-r 选项告诉 netstat 显示您计算机的路由表。为了帮助您正确解释输出，让我解释一下这些列的含义:

*   **“目的地”列**表示数据包的目的地与之比较的模式。当必须通过网络发送数据包时，会从上到下检查该表，然后使用具有匹配目的地的第一行来确定将数据包发送到哪里。192.168.1.0 中的零表示“匹配这个位置的任何东西”，所以 192.168.1.53 匹配，192.168.1.254 也匹配，但是 192.168。**2**0.254 不匹配。“本地链接”标签代表 169.254.0.0，这是一个特殊的 ip 地址范围，在没有其他方法来确定计算机应该拥有哪个 ip 地址时使用(没有 DHCP 或静态配置的地址)。“默认”标签代表 0.0.0.0，显然可以匹配任何目的地；最后一行是包的总称。
*   **“网关”栏**告诉计算机将与同一线路的目的地相匹配的数据包发送到哪里。星号(*)在这里表示“本地发送”，因为目的地应该在同一个网络上。“smoothwall”网关实际上是示例计算机网络中的一台计算机，它过滤 web 流量并可以访问互联网，因此发往任何非本地目的地的数据包被发送到那里是有道理的，这样它就可以将其转发到互联网。
*   **“gen mask”列**有些高级(它告诉您从 ip 地址开始有多少位用于标识子网，如果这对您有意义的话)，但是，根据经验，对于目的地的任何非零部分，它是 255，对于目的地为 0 的部分，它是 0。
*   **“标志”栏**显示哪些标志适用于当前表格行。“U”表示向上，表示这是一条活动线。“G”表示这条线路使用网关。
*   **“MSS”栏**列出了该行的最大段尺寸值。MSS 是一个 TCP 参数，用于在目的地指示它无法处理较大的数据包时拆分数据包。现在大部分电脑对最常用的最大数据包大小都没有问题，所以这一列的值通常为 0，表示“没有变化”。
*   **“窗口”列**类似于 MSS 列，因为它给出了改变 TCP 参数的选项。在这种情况下，该参数是默认的窗口大小，它表示在至少有一个 TCP 包必须被确认之前，可以发送多少个 TCP 包。如果你不知道这意味着什么，不要担心。与 MSS 一样，该字段通常为 0，表示“无变化”。
*   **“irtt”列**代表初始往返时间，并且可以被内核用来猜测最佳 TCP 参数，而无需等待缓慢的回复。实际上，它用得不多，所以在这里你可能再也看不到除了 0 以外的任何东西。
*   **“I 接口”栏**告诉我们应该使用哪个网络接口来发送与目的地匹配的数据包。如果您的计算机连接到多个网卡上的多个子网，您可能会发现一些线路的接口为 eth0，而其他线路的接口为 eth1。见鬼，即使第二块网卡没有连接但刚好可用，表中也可能有它的一些路由规则。

因此，当您的计算机将要发送数据包时，它会查看该数据包的目的地，然后开始逐行将其与路由目的地进行比较。假设计算机要发送目的地为 192.168.1.31 的数据包。这个 ip 地址匹配 192.168.1.0，因为 0 匹配那个位置上的任何东西，所以数据包被发送到 eth0 接口的本地网络(因为网关是*)，而不改变 MTT、Window 或 irtt 值。

假设计算机想要发送一个数据包到 208.67.222.222(主 OpenDNS 服务器)。此 ip 地址与 192.168.1.0 不匹配，因此跳过第一行。它也不匹配本地链路(169.254.0.0)，所以第二行也被跳过。ip 地址确实与 0.0.0.0 匹配(任何 ip 地址都匹配)，因此数据包被发送到 smoothwall (192.168.1.1)以转发到互联网，在那里，它可能在多跳几跳后到达 OpenDNS 服务器。

通常，您的路由表中的默认线路设置是正确的，您不必担心这一点。然而，路由表中的一条错误线路可能会阻止部分或全部互联网流量到达目的地。当这种情况发生时，您经常得到的错误是“没有到主机的路由”。遗憾的是，这种错误在许多其他情况下也会出现，但是如果您遇到这种情况，无论如何都要看看您的路由表。如果它包含一个错误的行或者缺少一个重要的行，您可以使用 route 命令来更改/添加它(在您的命令行中运行“man route”来查看它是如何工作的)。

## 显示接口和统计数据

使用 netstat，您可以列出机器上可用的接口，并读取一些关于它们运行情况的统计数据。一个例子:

> netstat-Iker 接口表分析 MTU met rx-ok rx-err rx-DRP rx-ovr tx-ok tx-err tx-DRP tx-ovr flgeth 0 1500 0 250055 0 1420 390 0 0 bmrulo 16436 0 16 0 0 0 16 0 0 0 LRU

你可能注意到了，这些列有点乱。如果不确定某个值属于哪一列，请计数！每行中的字段数和列数一样多，所以它们是匹配的。说到列，让我给你解释一下它们的含义:

*   **“I 接口”列**包含显示统计数据的接口名称。主网卡通常称为“eth0”。环回接口(缩写为“lo”)是一个虚拟网卡，它允许计算机在不打扰硬件设备的情况下与自己建立网络连接(还记得网络连接部分的 Google Talk 插件吗？)，从而提供更好的性能。
*   **“MTU”栏**列出了该接口一次可以发送的最大传输单元。它是在相当低的级别上使用的字节数，这意味着无需拆分即可发送的 TCP 数据包的实际最大大小要小几十个字节。
*   **“RX-OK/ERR/DRP/OVR”列**给出了迄今为止接口接收到的数据包的统计信息。“OK”代表“正确接收”，“ERR”代表“接收到，但校验和不正确”(当连接不好时)，“DRP”代表“因为我的接收缓冲区太满而被丢弃”(当在很短的时间间隔内接收到太多数据包时)，而“OVR”代表“因为内核无法及时获得而被丢弃”(如果发生这种情况，您的计算机*真的*忙)。
*   **“TX-OK/ERR/DRP/OVR”列**与 RX 列大部分相似，除了它们是关于到目前为止由接口*发送*的数据包。
*   **“Flg”列**包含该接口激活的标志。“B”表示“广播能力”，意味着此接口可以向同一子网上的所有人广播数据包。“M”表示“多播能力”，意味着该接口可以发送具有多个目的地的数据包。“L”表示“环回接口”，这意味着这是一个将随其发送的所有内容立即放入其自己的接收队列中的接口。“U”和“R”分别表示“向上”和“运行”。我想我不必解释这些。).

在本例中，请注意“RX”和“TX”的“ERR”、“DRP”和“OVR”列中的漂亮的零。显然，这里的网络状况良好:)。

还要注意“lo”接口的 MTU 值。16436 字节超过了任何正常的真实网络接口所能提供的，因此应该能够发送任何包而不需要分割。这进一步提高了环回接口的性能。

给你一个提示:如果你的网络看起来比它应该慢得多，你可能想运行“netstat -ci”来查看你的网络统计数据每秒的更新。如果“错误”、“DRP”和/或“OVR”值持续增长，那么您的网络中一定有猫腻。检查干扰和/或不良交换机或路由器。在 Windows 和 Mac 上，您需要使用稍微不同的命令来做同样的事情。在 Windows 上，应该运行“netstat-E1”(-e 替换-i)。在 Mac 上，“netstat -iw 1”。

这是这三个平台共有的三个 netstat 功能，但还有更多。Linux netstat 可以使用“-m”来显示伪装的连接，而 Mac 使用相同的选项来显示内存管理统计信息。

Linux 和 Mac 都可以使用-g 选项显示组成员。这些额外的功能不常使用，但是如果您想了解更多，可以在命令行中运行“man netstat”来获得更多信息。并且不要害怕自己做一些实验；netstat 只显示信息，你不会破坏任何东西。

如前所述，只有对网络和 Linux 系统了如指掌，才能真正有效地使用 netstat。如果您想提高您的 Linux 知识，请查看我们的[培训库](https://acloudguru.com/training-library/linux-training)的 Linux 课程和动手实验室！