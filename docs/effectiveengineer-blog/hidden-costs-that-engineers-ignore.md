# 工程师忽略的隐性成本

> 原文：<http://www.effectiveengineer.com/blog/hidden-costs-that-engineers-ignore>

“我只需要几个小时就能实现这个特性，”我们有时会这样说。但在完成之后，我们发现每隔几周，我们要么用该功能修复一个 bug，向另一个工程师解释它，要么帮助回答客户支持关于它如何工作的问题。维护特性的总时间投入远远超过最初几个小时的开发。

软件工程中最难消化的一课是额外复杂性的隐藏成本。有时候，复杂性是问题空间固有的。在调整价格以平衡供需的同时匹配乘客和司机是一个复杂而艰难的问题。将问题和答案发送给最有可能回答和阅读它们的人，同时扩展社区并保持质量，也是如此。或者开发一个能够在所有设备上良好工作并支持实时协作的富文档编辑器。这是我们需要克服的固有的复杂性，以便产品取得成功。

但其他时候，我们与之搏斗的复杂性是我们自己引入的复杂性。我们用很少有人知道的新编程语言编写代码，现在我们必须维护它。或者，我们添加了额外的基础架构，因为我们想尝试我们在黑客新闻上看到的新的热门技术堆栈，但它以我们最初没有预料到的方式失败了。或者我们引入了一个很少有人使用的特性，但是这个特性通过修复和错误报告消耗了我们大量的时间。

额外的复杂性带来了许多隐性成本。我们在构建软件时所做的决定不仅仅决定了我们当前的开发速度。它们还会影响我们在未来维护它所花费的时间和精力。

## 复杂性的隐性成本

太多的复杂性会增加认知开销，并给完成工作带来额外的摩擦。它以多种不同的方式渗透到团队中——最直接的是通过代码、系统和产品的复杂性，但间接的是通过组织的复杂性。让我们逐一看看这些不同类型的复杂性的隐藏成本。

### 代码复杂性

代码复杂度不仅仅是代码行数的线性函数，而是组合增长。在复杂的代码库中，每一行代码都可能与许多其他代码行相互影响。我们很难理解组合增长，这就是为什么我们倾向于严重低估完成大型软件项目所需的时间。这就是为什么重写项目有时会大幅度推迟进度的主要原因。

当代码太复杂时，它变得更难提升，更难推理，更难修复错误。很难理清依赖关系和数据流来追踪错误的来源。工程师可能会主动避开代码库中最复杂的部分，选择绕过它，即使它是进行某种更改的最合理的地方。或者，他们可能会避免在这些领域一起工作，即使工作可能会产生重大影响。

### 系统复杂性

工程师喜欢摆弄新玩具，无论是因为他们好奇，还是因为他们认为新技术可能会为解决他们的一个紧迫问题提供一颗银弹。当 Pinterest 在 2011 年最初扩展其网站以应对快速增长时，他们在只有 3 名工程师的后端团队中使用了 6 种不同的存储技术(MySQL、Cassandra、Membase、Memcache、Redis、MongoDB)。他们试验的每一项新技术在理论上都承诺解决他们现有系统的一些限制。但是相反，他们发现每个新的解决方案都以其特有的方式失败，并且需要花费更多的时间和精力来管理和维护。最终，该团队认识到，通过添加更多的机器而不是更多的技术来扩展会更简单，因此他们淘汰了 Cassandra 和 MongoDB 等系统，并加强了其架构的剩余组件。

将基础设施分割成太多的系统会带来许多隐性成本。注意力分散在多个系统中。将资源集中起来为每个系统构建可重用的库变得更加困难，为传呼机任务增加新人变得更加困难，理解每个系统的特定故障模式和性能特征变得更加困难。每个系统的抽象最终会变得更弱，因为没有投入太多时间在每个系统上。当工具和抽象太复杂或者太多的时候，团队很难理解和发现它们。

### 产品复杂性

产品的复杂性可能来自于一个不明确的愿景或者一个无节制的野心，导致缺乏产品焦点。这种想在很多方面都做得很好，而不是只在一个核心领域做得很好的愿望，有时会表现为无法向新用户简明地解释产品的用途。产品的复杂性导致更多的代码和系统复杂性——团队添加更多的代码和更多的基础设施来支持新的特性。当一个产品有一个很宽的表面区域时，增加一个新的功能或者修改一个现有的功能需要花费大量的精力去理解和适应旧的功能。

一个过于复杂的产品意味着有更多的代码分支，更多的问题需要考虑，团队需要解决更多的错误报告。工程师和数据科学家需要分析更多的变量，做更多的一次性报告，而不是专注于理解核心用户行为。工程师需要投入更多的时间来拓展特性空间并提高工作效率。每个人最终都会在更多的项目之间进行上下文切换。花费在维护所有这些特性上的时间并没有花费在代码的再投资、偿还技术债务或加强抽象上。

### 组织复杂性

代码、系统和产品的复杂性反过来又滋生了组织的复杂性。团队需要雇用更多的人来处理和维护已经建立的一切。更大的团队意味着更多的沟通开销、更多的协调和更低的整体效率。招聘过程本身，包括所有的面试和汇报，会消耗团队很大一部分时间。当然，所有新员工都必须接受培训和入职。

雇用更多人的替代方案是将工程组织分成更小的团队——甚至可能创建一个人的团队——来覆盖大的代码、系统和产品表面区域。这减少了沟通开销，但是[单人团队有他们自己的成本](/blog/beware-the-one-person-team)。更容易遇到完全阻碍项目中唯一一个人的障碍，因为可以分享这些低谷的人更少，这种经历对士气更不利。与他人合作的机会越来越少，这可能会损害工作场所的幸福感和员工的忠诚度。除非每个人都意识到并积极主动地要求反馈，否则个人可能会收到较少的关于他们工作的反馈，因为很少有人分享相同的项目背景。减少的反馈会导致较低质量的代码或无意中引入代码库或基础结构的复杂性。

## 如何对抗复杂性

东尼·霍尔在他 1980 年的图灵奖演讲中提出，“有两种方法来构建一个软件设计:一种方法是让它简单到没有明显的缺陷，另一种方法是让它复杂到没有明显的缺陷。”在讨论了复杂性导致的不明显的缺陷如何伤害我们之后，我们如何保护自己免受这些成本的伤害呢？

以下是一些你可以使用的策略:

*   **为了简单而优化。**抵制增加更多复杂性的冲动。通过维护成本进行推理。问问你自己，解决问题的最后 20%所带来的复杂性是否值得，或者 80%的解决方案是否足够。

*   为你的团队或产品定义一个使命陈述，以协调焦点。在 [*团队极客*](http://www.amazon.com/Team-Geek-Software-Developers-Working/dp/1449302440?tag=theeffeengi-20) 中，Brian W. Fitzpatrick 和 Ben Collins-Sussman 解释了他们如何指导谷歌网络工具包(GWT)团队，并鼓励他们写下一份使命陈述。接下来关于使命陈述的内容和风格的争论揭示了首席工程师实际上并没有在产品方向上达成一致！他们被迫面对并调和他们的分歧，最终得出结论，“GWT 的使命是通过使开发者能够使用现有的 Java 工具为任何现代浏览器构建不折不扣的 AJAX，从根本上改善用户的网络体验。”如果他们没有更快地解决分歧，会导致多少努力的分散？

*   从简单的构建块组成大型系统。Google 是一个专注于构建强大的核心抽象，然后广泛应用于各种应用的组织的例子。它们有基本的构建模块，如协议缓冲区、Google 文件系统和用于远程过程调用的 Stubby 服务器。在这些构建模块之上，他们构建了其他抽象，如 MapReduce 和 BigTable。除此之外，成千上万的应用程序，包括大规模网络索引、谷歌分析网站跟踪、谷歌新闻聚类、谷歌地球数据处理、谷歌时代精神数据分析等等，都被构建出来。^()

*   **明确定义模块和服务之间的接口。**模块和服务的解耦减少了组合的复杂性，否则这种复杂性会从一堆代码中增长出来。在亚马逊，杰夫·贝索斯在 2002 年宣布，公司将转向面向服务的架构，所有团队只能通过服务级接口相互交流。^(虽然这种转变带来了巨大的开发成本，但它加强了服务背后的代码和逻辑的分离，并促进了现在非常成功的亚马逊网络服务的创建。)

*   **定期还清技术债务。我们总是在不完全信息下构建软件。随着代码库响应不断变化的条件而有机增长，熵也会增加。增加的复杂性成为未来发展的负担。在开发计划中安排时间有助于降低成本。许多工程师和团队会对项目之间的时间进行预算，但举办一次性活动也会有所帮助。在 Quora，我曾经组织过一次代码清理日，工程师们集中精力删除代码库中不用的代码。我们在排行榜上跟踪代码清除的进度，这比自己删除代码有趣得多。**

*   **使用数据修剪未使用的特征。**在 Yammer，当工程师或产品经理发现增强一个特性或在代码重构中保留它需要付出大量的努力时，他们会查看使用数据以了解该特性是否被实际使用。如果没有，他们会和团队一起决定是否应该削减功能以减少整体工作量。^(这种策略减少产品债务的方式类似于简化代码减少技术债务的方式。)

*   **围绕主题对正在进行的项目进行分组。**这使得团队成员能够彼此共享相同的上下文，这使得参与设计讨论、审查代码或构建可重用库变得更加容易。所有这些活动都有助于提供检查和平衡，个别工程师可能会引入这些检查和平衡。

当我们为学校课程开发软件时，我们得到了一个过于简单的世界观——维持任何复杂性的成本在一堂课结束时都消失了。但在我们的职业生涯中，糟糕的软件决策可能会在未来几年征收税款。

不要把事情复杂化。