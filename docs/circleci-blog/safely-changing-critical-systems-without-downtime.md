# 如何在不停机的情况下更换关键系统| CircleCI

> 原文：<https://circleci.com/blog/safely-changing-critical-systems-without-downtime/>

## 如何在不停机的情况下更换关键系统

自信地[在生产中测试](https://circleci.com/blog/a-rational-guide-to-testing-in-production/)对于工程师快速交付软件至关重要。在这篇博客中，我们将讨论 CircleCI 团队在改变我们的关键系统时学到了什么。

### 权限检查带来的挑战

每当 CircleCI 用于任何事情时，我们都要检查以确保该操作得到授权。有时我们需要对一个动作进行多次检查。

例如，如果您使用我们的 API 启动一个新的工作流，我们需要检查您是否被允许启动该项目的工作流，以及您是否被授权使用该工作流使用的任何上下文。这意味着大量的权限检查。我们每秒钟执行数千次这样的检查，每次都需要尽可能快地得到正确的答案。

这些权限检查的最初实现完全基于 GitHub 的访问模型。如果我们需要检查你是否可以开始一个新的构建，我们会检查你是否可以推到相应的 GitHub 库。

随着时间的推移，这逐渐发展到包括缓存层、重试、位存储桶支持和许多其他复杂性，包括:

*   实现逻辑被分成两个子系统，所以我们必须知道使用哪一个取决于我们正在做的权限检查的类型。这是之前一次重构尝试的结果，由于优先级冲突，该尝试中途被放弃。
*   CircleCI 曾经是一个单一的服务，其中一个实现仍然在代码库中。这使得新服务很难执行授权检查。
*   由于许多权限检查依赖于调用 Bitbucket 或 GitHub APIs，我们很容易受到这些 API 的性能或可用性问题的影响。两个独立的实现在这里也没有帮助，因为它们在停机期间的行为是不一致的。
*   一些检查依赖于“用户档案”,这是一个昂贵的构建缓存，包含我们从用户的 GitHub 和 Bitbucket 账户中了解到的所有信息。这导致了负面的长尾效应。如果你从许多不同的 Bitbucket/GitHub 组织建立了大量的回购，你要么得到一个即时的结果，要么等待配置文件建立超时。
*   我们希望允许用户明确地授予任何权限，而不被绑定到他们的 Bitbucket/GitHub 访问，但是只有一个子系统支持这样做。

## 在不影响客户体验的情况下执行迁移

我们决定通过将所有检查从整体转移到另一个子系统来完成之前尝试的重构。同时，我们对其进行了清理，删除了对“用户配置文件”的使用，以提高可靠性和性能。执行迁移必须在不对客户体验产生负面影响的情况下完成，因此我们在大约一年的时间里缓慢而谨慎地完成了迁移。

## 第一步:添加日志记录并收集指标

我们的第一步是在两个权限实现上创建一个外观，并强制所有检查都通过该外观来执行。这为我们提供了一个添加日志记录和收集指标的地方，这样我们就可以测量每个权限检查的基线性能和可用性。更重要的是，它允许我们在每个权限检查的实现之间切换，而不需要更改调用代码。

## 第二步:一次迁移一个权限检查

下一步是将每个权限检查迁移到最终目的地。我们对这些迁移非常谨慎，因为我们必须满足一些严格的标准:

*   新实现必须返回与旧实现相同的结果。我们不能意外地允许某人访问他们应该被禁止使用的东西。
*   新的实现必须至少和旧的一样快。不仅其平均延迟必须相同或更低，而且其长尾延迟应保持在可接受的范围内。比较了平均值、中间值、第 95 个百分位数和第 99 个百分位数的计时，以确保性能可以接受。
*   新的实现必须具有与旧的实现相似或更好的可用性。Bitbucket 和 GitHub 中断期间的行为必须是可预测的，并且必须尽可能将这些中断的影响降至最低。

### 如何进行个人权限迁移

对于每个单独的权限迁移(从实现 A 到实现 B ),我们遵循以下过程:

1.  原状。我们调用了所有检查。
2.  脚趾在水里。我们为所有的检查调用了 A，但是在后台线程中，我们也为 1%的检查调用了 B。我们比较了结果，并记录了它是否产生了相同的答案。我们还记录了 A 和 b 的性能数据。
3.  在后台慢慢调高音量。我们继续提供来自 A 的所有答案，但是我们逐渐增加了通过 B 在后台完成的检查的百分比。此时，我们正在寻找实现中明显的 bug，并确保 B 可以安全地承担 100%的请求负载。
4.  在后台 100%运行 B 时，我们检查了任何不一致之处，并修复了导致这些不一致的错误。这是我们能够做一些快速迭代的地方，因为我们在 B 上迭代，它仍然在后台，对客户不可见。部署后，我们的反馈几乎是即时的，但如果我们犯了错误，几乎没有破坏东西的风险，所以您可以快速移动，直到我们在 A 和 b 之间达成 100%的一致。
5.  慢慢地部署它。我们停止在后台运行 B 的签入。在一段时间内，我们向 A 发送了 X%的流量，向 B 发送了 Y%的流量，慢慢地减少了 X %，增加了 Y%。我们知道现在的实现是等效的，但是我们希望小心不要在性能不同的情况下突然引起客户可见的变化。
6.  让它浸泡。我们让 B 以 100%运行一段时间，这样我们可以在一个完整的负载周期内验证它的性能和行为。这让我们建立了更多的信心，我们没有错过任何极其罕见的错误。
7.  移除旧的实现。通过移除一个。

选择使用哪个实现和/或在后台运行的百分比都是由可以立即改变的开关驱动的。即使到了上面的第六步，我们也可以用一个命令立即恢复到最初的实现。

## 第三步:清理安全权限

最后一步是清理用于切换的代码。度量和日志记录代码可以保留，因为随着时间的推移监视我们的权限检查的行为仍然是有价值的，但是我们能够删除用于在实现之间切换的代码。这种简化很重要，因为它允许新工程师更快地熟悉代码。

## 从生产测试中吸取的经验教训

生产中的测试为我们的团队提供了许多见解，帮助我们更快地交付更好的软件:

1.  缓慢而小心地移动可以提高整体开发速度。当工程师对他们做出改变而不面对客户后果的能力有信心时，他们可以快速迭代。
2.  在客户看不见的背景下推出新的东西，是在生产中进行测试的强大工具。我们可以通过良好的设计和生产前测试来建立信心，但总是有未知的未知，而这些只能在生产中发现。如果你能在顾客没有注意到的情况下做到这一点，你就能在他们造成任何有意义的影响之前解决他们。
3.  功能切换是恢复错误更改的最佳方式。服务需要时间回滚到以前的版本，恢复源代码控制和重新部署中的更改甚至更慢(这使得您的 git 历史更难跟踪！).
4.  良好的遥测技术至关重要。我们能够使用数十亿个数据点来建立对我们的变化的信心，并产生非常稳定的时间分布。

要了解关于这个主题的更多信息，请下载我们的电子书，[](https://circleci.com/blog/a-rational-guide-to-testing-in-production/)*生产测试的理性指南。*