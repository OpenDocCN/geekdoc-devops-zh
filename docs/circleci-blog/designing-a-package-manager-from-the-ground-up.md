# 设计一个包管理器:CircleCI orbs 的内幕

> 原文：<https://circleci.com/blog/designing-a-package-manager-from-the-ground-up/>

不到三个月前，我们[发布了 CircleCI orbs](https://circleci.com/blog/announcing-orbs-technology-partner-program/) ，这是我们针对 CircleCI 配置的软件包管理生态系统。在那段时间里，我们已经看到在最初的 10 周内创建了超过 300 个 orb，超过 200 个组织在超过 1，000 个项目的数万个构建中使用 orb。我们还通过新的[技术合作伙伴计划](https://circleci.com/partners/)推出了 20 多个官方合作伙伴 orb。我们非常感谢巨大而积极的回应。

在这篇文章中，我想回顾并分享创建和推出 CircleCI orbs 的关键设计决策。如果您现在正在使用 orbs，并且想要了解如何从它们那里获得最大的收益，或者如果您正在考虑设计自己的包管理系统，那么这篇文章就是为您准备的。

### 什么是 CircleCI 球体？

orb 是 CircleCI 配置的可共享包。像大多数其他代码打包系统一样，orb 提供了一组通用的抽象结构元素，使得在您的组织以及更广泛的用户生态系统中重用经过测试、封装的构建组件变得切实可行。orb 有一个用 YAML 语法定义的领域特定语言(DSL ),它表达了我们的构建配置的语义。这使得在构建配置中为封装的命令、作业和执行器编写惯用接口变得简单。

orb 还提供包管理基础设施。这使得发布清晰版本化的 orb，然后导入它们用于项目变得简单。

## 球体的设计是为了解决什么问题？

我们的工作是帮助团队激活并加速他们的软件交付。充分利用 CircleCI 的关键要素之一是我们的构建配置，这是一种基于 YAML 的语义，用于描述 CI 管道的工作流、作业和环境。当我们开始构建 orb 时，我们希望解决与构建配置相关的三个关键问题:

**1。更好的干支持**
circle ci 2.0 中的配置被设计成高度透明、富有表现力和确定性的。然而，这些特征也会使我们的基本语义变得冗长和重复。如果没有好的快捷方式和甜言蜜语，配置可能会有很多样板代码，阻碍项目的设置，并且随着复杂程度和范围的增加，配置变得难以使用。
**2。跨项目的代码重用**
许多客户想要更好的方法来跨项目共享配置。CircleCI 配置以前不容易在团队之间共享，这造成了不必要的冗余并降低了团队的速度。我们拥有大型团队的客户希望能够轻松地传播和实施通用的模式和策略，并通过共享的实践来帮助他们的团队改进。
**3。更容易实现通用配置**
开发人员试图避免重新发明东西或重新解决已解决的问题。在引导代码时，只要实用可靠，他们就希望使用现成的、经过改进的封装。在 CircleCI 中，对于第一次使用的用户来说，从空白页开始可能会令人望而生畏，我们希望让从一无所有到有用的东西变得更容易。

## 关键设计决策(以及我们做出这些决策的原因)

正如我们所料，设计一个新的包管理系统并不是一个简单的过程。在构建 orbs 时，我们需要平衡可接近性、可表达性、可移植性和确定性。我们回顾了其他包管理系统以及各种配置模板方法，并很快集中在我们想要合并的几个关键元素上。

因为 orb 比大多数通用包管理器更专注于它们的范围，所以我们在设计决策中有更多的主见。在这个过程中，我们对设计的各个部分进行了内部和外部预览，这使得我们可以在代码中嵌入任何东西之前获得快速的反馈。

在进入 orb 本身的设计之前，让我们从我们正在构建的底层 CircleCI 配置模型的一些上下文开始。

### 关于 CircleCI 配置的现有决策

当我们开始 CircleCI orbs 的设计过程时，我们知道我们将坚持 CircleCI 配置的现有设计原则:

**1。代码中的配置:**总是允许代码本身包含需要完成的配置，除非设置或其他输入绝对有必要存在于代码之外(例如:项目设置打算自动应用于所有分支，或者秘密注入和安全，打算存在于代码库之外)。

**2。确定性:**给定相同的输入，每个构建都应该有相同的行为方式。这可以防止你无法控制的事情改变你，同时减轻 CircleCI 不得不做出并执行关于你想要如何运行你的构建的假设。

**3。使用 YAML 是因为它提供了一种在语法权重和表达性之间取得合理平衡的方式来创作数据结构。让配置成为数据而不是编程语言，可以提供简单可靠的工具来进行配置语法和模式验证、在构建过程中进行各种静态分析和数据转换，以及使用一流元数据进行自动化文档编制。例如，Jenkins 插件的配置本身不是可执行代码。另一方面，orb 可以被推理为配置组合，而不是特定环境中的可执行软件。虽然这并没有解决所有的依赖性和安全性问题，但是它在您希望如何配置执行期间运行时环境内部发生的构建之间创建了更清晰的界限。**

**4。构建行为的声明性:**circle ci 配置的语义围绕着我们平台内部构建执行的核心域模型。核心结构由调用和协调作业的工作流驱动，这些作业表达了一组要运行的步骤以及运行这些步骤的执行环境。我们的配置代码本质上是您构建过程的元代码，因为我们提供了上层结构，您可以在其中表达自己的运行时命令和流程编排。我们想让你专注于你的代码在运行时内要做什么，尽可能不碍事。使用声明性语法可以给你一组有表现力的原语，而不需要你学习太多关于我们内部系统如何工作的知识，或者学习一些新的编程语言。

在着手构建 orb 时，CircleCI 配置的现有设计成了我们的关键约束。除了这些限制，orb 设计还有三个关键领域(排名不分先后):

 ***   orb 注册表的设计

*   orbs 的开发生命周期

*   我们的领域特定语言(DSL)的语义

下面，我将逐一介绍这些领域以及我们所做的决定。

### 设计 Orb 注册表

我们最初的设计建议从位于您的`.circleci`文件夹中的“本地”球体开始，这些球体将在运行时被拉入。里面有球体。circleci 被认为是不可接受的风险，因为我们与 GitHub 的互动方式。“不要把 git 当成一个包管理器”是我们内部对这种情况的明确警告。这产生了拥有我们自己的注册中心的需要，这无疑增加了大量的范围(大约 60-90 天的时间)并创建了一个清晰的设计边界。

**1。所有的球体都存在于一个命名空间中:**所有的球体都存在于一个命名空间中。没有“空”的名称空间，也没有为 CircleCI 或“官方”orb 保留的特殊默认值，如`_`。我们决定不希望我们创作的 orb 被认为是默认集合，或者在我们的命名空间方案中有特殊的意义。我们可能会在未来引入一个认证的 Orbs 程序或类似程序，但这将在 orb 上提供一流的元数据，明确定义包含，而不是依赖于来自特殊名称空间的含义。

**2。语义版本化和锁定:** CircleCI 希望允许 orb 作者动态地向 orb 添加特性和修复。同时，我们希望防止 orb 用户下的事情发生变化:修复用户使用的 orb，以便用户的配置保持静态，除非用户另有指定。CircleCI 选择在所有发布的修订版上强制执行严格的语义版本化格式。当导入时，我们允许 orb 用户锁定一个特定的版本或承担损坏的风险，并使用最新的版本(易变的)。

**3。“易变的”而不是“最新的”:**我们选择使用“易变的”而不是“最新的”，因为我们希望鼓励使用特定的版本来获得更大的确定性。我们希望使用`volatile`的人明白他们正在做的事情会有被破坏的风险。我们认为“最新的”听起来新鲜而新颖，而“易变的”更好地表达了当您愿意采取可能会毫无预警地任意变异的上游依赖时所发生的事情。同样值得注意的是，我们没有默认“volatile”或任何版本——在调用 orbs 时，您必须至少指定一个部分 semver 或“volatile”。

**4。认证与第三方 orb:**认证意味着 CircleCI 将其视为我们平台的一部分。如果使用 2.1 或更高版本的配置，任何人都可以使用它们，而无需额外选择加入。目前，只有`circleci`名称空间得到了认证，因为这些 orb 是我们自己编写的。所有其他人都被视为第三方。

**5。开放与私有球体:**所有的球体都是开放的，这意味着它们是全球可读的。任何人都可以使用它们并看到它们的来源。我们不想在你的代码和秘密的运行时环境中引入黑盒，所以如果你要在你的工作中运行 orb，你应该能够看到它们在做什么，这很重要。我们很可能会在未来增加一些拥有私人球体的方法。

### Orb 发展决策

orbs 系统的核心是开发 orbs 的开发人员如何工作。这里的首要任务是平衡迭代的容易程度和从小处着手，并考虑到持久性和不变性，允许 orb 的用户能够将它们合并到他们的构建中。以下是 orb 创作体验的主要特征。

**1。修订版是不可变的:**为了防止神秘的变化出现在那些使用 orb 的人的构建中，我们不允许在 orb 修订版上线后对其进行修改。要发布新版本的代码，您需要发布新的修订版。

**2。开发与生产 orb:**一旦我们决定对生产 orb 实施严格的、不可变的版本控制，我们希望有一种好的方式让你开发 orb 而不污染你的 semver 进程。因此，orb 既可以作为“dev:foo”发布，也可以作为语义版本化的生产 orb 发布。开发 orb 可以被团队中的任何人更改，并在最后一次发布日期后 90 天到期。生产 orb 是不可变的和持久的，因此您的构建配置不会受到您使用的 orb 中的意外变化的影响。

**3。注册时依赖关系解析:**如果一个 orb (my-orb)导入了其他 orb，我们将在 my-orb 被添加到注册表时解析并锁定那些依赖关系。例如，假设您发布了 my-orb 的 1.2.0 版本，它包含这个 orb 调用:`foo-orb: somenamespace/some-orb:volatile`–当您注册 my-orb 的 1.2.0 版本时，foo-orb 的最新版本将被整合到 my-orb 的 1.2.0 版本中。如果 foo-orb 的一个新版本发布了，它不会被合并到 my-orb 中，直到你发布一个新版本。我们建议选择您导入的 orb 的完全限定版本，以确保确定性行为。

**4。透明性:**如果你可以执行一个 orb，你可以看到这个 orb 的源代码。这就是为什么你永远不会在你的工作中执行一个黑盒，那里有你的代码和秘密。orb 不太像你的核心软件，而更像一个你可以复制和粘贴的配置。orb 是你构建过程的一部分，所以如果你能执行它们，你应该能看到它们做了什么。

### DSL 设计决策

在 orbs 内部，我们基于 YAML 的领域特定语言(DSL)的语法和语义需要得到增强，以允许参数化和重用。以下是我们在这方面做出的一些重要决定。

**1。orb 打包特定的配置元素，而不是提供通用的模板解决方案。**环顾其他工具，我们看到一些使用通用模板在项目间共享代码片段的配置实例。我们很早就决定将 orb 的重点放在使用我们的配置 DSL 的语义上，并允许调用特定的元素，这样就可以在特定的范围内使用参数，并避免意外的冲突。这种方法也使得配置更容易阅读和推理。

**2。内置/一流元数据。CircleCI 允许描述键作为 orbs 结构的一部分，因此生成文档或通读代码更容易，不需要额外的结构注释。**

**3。orb 是 config.yml.** 的子集。您可能会注意到您的`config.yml`文件中的配置格式与 orb 非常相似。一开始，很明显 config.yml 实际上是一种特殊的 orb——您可以将它视为在 CircleCI 上运行您的构建的“根 orb”。

## 下一步是什么？

我们很高兴看到这么多团队在短短几周内发布和使用 orbs。在整个 2019 年，我们希望为 orb 添加一些新功能，并继续构建我们自己的 orb，并与我们的合作伙伴合作，使与他们的系统集成更加容易。下面是几个资源，可以了解更多信息或参与帮助我们塑造构建配置的未来。

要了解更多关于使用或创作 orb 的信息，请参阅文档:[https://circleci.com/docs/orb-intro/](https://circleci.com/docs/orb-intro/)

要查看哪些 Orb 可以在您的配置中使用，请查看 Orb 注册表:[https://circleci.com/developer/orbs](https://circleci.com/developer/orbs)

要提出功能请求或投票支持现有请求，请查看我们的创意板:[https://ideas.circleci.com/?category=6605281645345952372](https://ideas.circleci.com/?category=6605281645345952372)

关于球体的一般讨论见我们的讨论板:[https://discuss.circleci.com/c/orbs](https://discuss.circleci.com/c/orbs)

相关博文:**