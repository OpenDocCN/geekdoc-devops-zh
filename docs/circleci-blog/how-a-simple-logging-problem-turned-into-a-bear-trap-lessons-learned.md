# 如何解决 Clojure | CircleCI 中的一个主要日志问题

> 原文：<https://circleci.com/blog/how-a-simple-logging-problem-turned-into-a-bear-trap-lessons-learned/>

> “开发人员被复杂性所吸引，就像飞蛾扑火一样，结果往往是一样的。解谜很好玩，开发者是解决问题的人。谁不喜欢匆忙解决一些极其复杂的问题呢？然而，在大规模软件中，在保留基本复杂性的解决方案的同时消除偶然的复杂性是具有挑战性的。”尼尔·福特

我用 Clojure 编码已经快 4 年了。我在 Clojure 中与登录斗争了将近 4 年。这并不是 Clojure 一个人的责任，但这似乎是一个经常遭受 Lisp 诅咒的问题。

在过去的一年里，当我在一个绿色的领域工作的时候(也就是，建筑[背景](https://circleci.com/docs/contexts/))，我再次遇到了一个伐木领域的“简单”问题……那就是我们吐出了我们所有的秘密。考虑到这可能足以阻止公开发布它，我的团队花了一些时间来深入挖掘，并追捕将我们的所有请求都写给`stdout`的错误类。

> 牦牛毛:做一些与你真正目标无关的事情。

许多牦牛后来剃光了毛发，我们发现自己在思考我们在 CircleCI 想要从伐木中得到什么的本质。我们知道这个问题有很多层面，但我们也知道我们可以把它变得更好。然而，一旦我们戳中了它，我们发现它很难逃脱。就像飞蛾扑火，或是被困在陷阱里的熊。

> 熊陷阱:一个一旦戳中，就有咬人倾向，难以逃脱的问题。通常情况下，这些问题你知道你可以做得更好，但当你深入研究时，你会发现这些问题有很多层面，其中包括你的同胞。

下面是 CircleCI 最近的“熊陷阱经验”案例研究:登录 Clojure 应用程序。我们所有的代码都可以在这里找到。

## 日志记录的问题

CircleCI 的日志记录基础设施有很多吸引人的地方:

*   分布式体系结构
*   分布式团队
*   每天执行超过 40 万个外来代码实例(可能是您的代码！)
*   Clojure 库
*   维护云、企业、测试 CI、开发和个人开发人员环境

为了做到这一切，我们依靠一些技术:

*   Clojure:我们选择的主要语言
*   [Kubernetes](https://kubernetes.io/) :服务编排等。
*   用于内部服务通信的 gRPC
*   [PostgreSQL](https://www.postgresql.org/) 用于长期存储
*   [用于加密和轮换客户端数据的保险库](https://www.vaultproject.io/)

所有这些因素加在一起会导致不小的问题。

### 难以减轻的错误

没有什么比看到[“AKIA……”](https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys)出现在你的日志中更好的了。或者可能更好:“{'cookies' ['password:guest '，…]”等。

不管我们喜不喜欢，我们都是人。当你在一家像我们这样规模的公司工作时，与我们在所有不同地方的人一起工作，同时使用可爱的传统整体产品和小巧的新型微服务，就会出现错误。

通过 gRPC，我们的上下文服务记录了所有转储到其中的环境变量，我们知道应该对注销凭证采取预防措施。为了实现这一目标，团队建立了伐木*危险预防*。这最终归结为代码中几个简单的基于正则表达式的过滤器，可以`<<REDACTED>>`任何*可能*相关的东西。

我们希望确保最终使用我们工具的人能够从中受益，并获得更大的回报。我们不想强制执行“更好的编码实践”或其他此类形式的羞辱新人的行为，我们只想让工具变得更好。套用这个比喻，试着给人们胡萝卜而不是大棒。

我们写了测试。我们验证了它的工作原理。在我们的内部测试中，我们看到我们所有的凭证仍然被记录。

由于这些过滤器没有在运行 Clojure 应用程序的 JVM 和聚合 stdout 的容器之间实现，因此我们需要确保我们的代码库正在查看所有的日志记录语句。不出所料，他们没有。

### 大约 5 种不同的日志记录框架(全部同时运行)

运行在 JVM 中的 Clojure 可以访问 Java 库和生态系统的巨大财富。像 HTTP 上的通信或加密之类的东西不需要完整地编写，因为其他人已经花时间为您提供了这些内容。这通常被认为是应该使用 Clojure 的主要原因之一。它是功能性的，适度的。

虽然 Java 社区在很多方面值得称赞(向后兼容性、Apache 等)。)，日志可能不在其中。既然这在 Java-land 是个问题，在 Clojure 也是个问题。

我们在我们的代码库中发现有 [6 个框架](https://xkcd.com/927/)写给`stdout`:

有些人会注意到 [LogBack](https://logback.qos.ch/) 不在这里。幸运的是，这不是我们发现注销的框架之一，但它是我们后来添加的一个(阅读下文)。

最终，我们希望所有这些都只通过*一个*记录器。我们希望能够简化我们的问题，缩小我们问题空间的范围。与其把你的整条腿伸进陷阱，为什么不只是一个脚趾呢？

我们当时的决定是[音色](https://github.com/ptaoussanis/timbre)。虽然从一个给定的记录器到音色的直接“桥接”输出对于上面的许多来说是不存在的，但是我们不需要它们，因为几乎它们中的每一个都有将其所有输出转发到 SLF4J 的方法。Clojure。工具。测井是*最有可能是* [已经在使用我们通过 SLF4J 输送的测井仪](https://github.com/clojure/tools.logging/blob/master/src/main/clojure/clojure/tools/logging/impl.clj#L234-L245)。由于 [SLF4J 有一个巨大的音色桥梁](https://github.com/fzakaria/slf4j-timbre)，我们完成了！

也就是说，所有 java-land 的日志被转发到 SLF4J，然后我们将 SLF4J 正在做的所有日志发送到 Timbre。详情如下。

#### 去 SLF4J

https://www.slf4j.org/legacy.html. SLF4J 在其网站上提供了一个很好的“处理遗留 API”自述文件:使用这个，你可以通过 SLF4J 谈论大多数事情。

虽然上面的大多数只需要在类路径中包含一些 jar，但是还有一些需要做更多的工作:

所以我们认为自己很聪明。然而，使用和索引任意日志条目不是一件小事，CircleCI 已经…

### 大量的日志

我们别无选择。我们每天生成大约 3 亿行日志。这是 1.5T。使用这些数据有多种形式:我们的安全团队依靠这些来审计客户的构建，我们的运营团队依靠这些来追踪比特币矿工，我们的开发人员依靠这些来进行监控/观察。如此多的人依靠这些日志来记录如此多不同的信息，结果是产生了大量的数据。通常，我们有专门的 prs 来寻找不再使用的日志行，以减少我们所携带的数据负载。

为了让我们所有人都能够从中获得我们需要的功能，我们必须解决许多问题，尤其是时区、不同的部署以及每个用例的专业领域。

因此，虽然存在像 [Logstash](https://www.elastic.co/products/logstash) 这样的工具，并且您可以很容易地添加“grok 过滤器”来解析日志行之外的字段，但是协调确保所有这些不同的过滤器*仍然工作*需要很多麻烦。

或者，您可以使用 JSON 作为传输工具。

我们不希望在我们的云和服务器产品中(或者在每个人的个人机器上)都处理这个问题，我们选择将消息作为 JSON 直接传输到 Logstash。有效载荷中出现的新字段被自动索引，时间戳“正常工作”。

最棒的是，有了结构化数据，编写单元测试变得轻而易举…

### 可测试日志记录

这一节很短，但以上都是[可测试的](https://github.com/AlexanderMann/unclogging/blob/master/test/alexandermann/unclogging_test.clj)。

Clojure Tools Logging 通过使用[协议和接口](https://clojuredocs.org/clojure.core/defprotocol)在可测试性方面做了[出色的工作，允许开发人员编写一个接收所有消息的记录器的假/模拟/存根实现。](https://github.com/clojure/tools.logging/blob/master/src/test/clojure/clojure/tools/test_logging.clj#L8-L17)

音色与[附加器](https://github.com/ptaoussanis/timbre/tree/master/test/taoensso/timbre/appenders)有相似之处。对于我们的用例，我们能够[注册一个测试 appender](https://github.com/AlexanderMann/unclogging/blob/master/test/alexandermann/unclogging_test.clj#L18-L44) 并检查将要被记录的语句。

将测试作为一项需求来构建我们的工具是我们可能做过的最好的事情之一。之前已经说过无数次了，但是尽早测试，经常测试。分布式团队的协调是很重要的。如果你关心什么，你最好写一个测试。

在你做任何改变之前设置测试。如果别人替你写了测试，那就偷出来。如果别人为你窃取了适用的测试数据，那就把它也偷走吧！测试让你成为你自己工作的早期消费者，并让你在别人试图使用你的解决方案时感到痛苦。

## 释放

> [自行车脱落](https://en.wiktionary.org/wiki/bikeshedding):辩论容易抓住的、无关紧要的项目，而不是问题的实质。

在将上述所有内容整合到我们的几个服务中，并且有了好运气之后，我们决定让团队的其他成员也参与进来。“测试版”的早期反馈过于积极。简单的设置，固执己见的配置，以及没有永远不会使用的旋钮和开关被吹捧为其最大的卖点。然而，内部版本几乎立刻就遇到了许多问题…

*   为什么我们要用[音色](https://github.com/ptaoussanis/timbre)，难道不应该用 X/Y/Z 来代替吗？
*   为什么要把这个烤成微服务框架？难道你不知道框架是魔鬼的作品吗？这不应该是一个独立的库吗？
*   我要做我自己的东西。

好心没好报，共享软件就是这样一种罪。作为开发人员，很容易将外部输入视为无知的感觉。但是，请记住反馈在构思生命周期中至关重要。这是我们改进和进步的方式。

### 第二波

大约在日志工作“完成”3 个月后，我们意识到我们需要更积极地思考常见事物应该如何在我们的生态系统中工作。我们希望给开发者必要的空间，让他们在这些问题上进行深思熟虑，所以 CircleCI 组建了一个团队，致力于在跨团队关注的领域开发工具。这个团队到目前为止工作得非常好(尽管我们确实怀念在 SRE 把东西扔过墙的日子)。

现在，团队正在发布日志工作，这似乎是一个突出那些没有成功的事情的好时机:

#### 采用足迹更小

虽然 Clojure 社区中许多人对框架概念的反应本身就很可笑，但是希望简单的问题有简单的解决方案并不可笑。

采用并随后必须支持一个服务框架来“解决日志记录”是荒谬的。试图快速解决我们最初的问题*最终混淆了我们解决方案的范围。相反，我们将我们的日志解决方案移到了它自己的库中。*

 ***回想起来，将我们所有的工作放在我们预先存在的回购中使得开发周期变得很快，但是采用周期变得很慢。**

在这些力量之间找到平衡是非常棘手的，也是我们一直努力解决的问题。

对于那些好奇的人，我之前在这里写过我们的[“服务工具”框架。我们背板团队的第一个目标是将我们的“微服务框架”分解为“微服务机箱”，以使采用变得简单和渐进。希望是因为团队需要更多的与第三方服务(滚动条，Postgres 等)的集成。)，他们可以抓住一个现成的机箱，毫不费力地将其安装到位。与他们自己构建相比，这将为他们提供更多的好处，并且添加它的开销将会很小。简单的问题，简单的解决方案，渐进的改变。](https://circleci.com/blog/reducing-microservice-overhead-with-shared-libraries/)

#### 基于正则表达式的危险预防

该团队发现，编写过滤器来删除秘密内容很麻烦，而且肯定不能保证捕捉到所有内容。相反，他们的解决方案将预防的动力放在那些首先引入安全媒介的人身上。如果一个新值被认为是秘密的，它将有一个没有`.toString`方法的特殊类型。相反，当`.toString`被调用时，`WARNING:REDACTED`将被返回。现在，使用这些秘密的人将不得不经历重重困难才能偶然记录一些东西。

```
(defprotocol SecretAccess
  (danger [this]))

(defrecord SecretWrapper
  [secret]
  SecretAccess
  (danger [this] secret)
  Object
  (toString [this] "<<REDACTED>>"))

(def x (SecretWrapper. "AKIAIOSFODNN7DAMNIT"))

x
=> #user.SecretWrapper{:secret "AKIAIOSFODNN7DAMNIT"}

(log/info x)
<<REDACTED>>
=> nil 
```

这是在我们的编程中积极主动和被动反应之间的微妙区别。被动是在问题已经发生后再去处理它。主动是利用能力从一开始就防止问题发生。最终，我们期望这里会有更多的迭代，我们将最终得到两者的结合。

#### 使用 Clojure 定义日志配置

虽然 Timbre 仍然是 CircleCI 的许多开发人员在未来的项目中用来登录的工具，但它在 Clojure 中的配置最终被视为前进的障碍。因为没有本机名称空间过滤，所以会传递更多不必要的日志消息，稍后再进行过滤。

目前，我们在一些共享服务容器中使用 LogBack 和一些嵌入式 XML 配置文件。最终开发人员无需进行配置，控制更加精细。

## 快乐黑客

发现小问题并逐步改善它们是一项神圣的工作。这也常常出乎意料的困难。我们希望不断反思我们是如何工作的，以及我们为什么做出决策，这将有助于我们在未来避免熊市陷阱。

总结一下上面关于熊市陷阱的知识:

*   尽早发现不同的观点和意见，将开发者的评论编织到构思生命周期中
*   奖励使用你代码的人，不要增加进入的门槛
*   试着简化你的问题，同时解决一些有意义的事情
*   协调一个分布式团队并不简单，试着自动化它(我们在 CircleICI 使用持续集成和测试，我知道这很令人震惊)
*   平衡您的开发周期时间和您的采用周期时间

一如既往，黑客快乐！*