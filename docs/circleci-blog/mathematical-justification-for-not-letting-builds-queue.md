# 模拟自动扩展构建集群第 1 部分:不让构建队列循环的数学证明

> 原文：<https://circleci.com/blog/mathematical-justification-for-not-letting-builds-queue/>

**来自出版商的说明:**您已经找到了我们的一些旧内容，这些内容可能已经过时和/或不正确。尝试在[我们的文档](https://circleci.com/docs/)或[博客](https://circleci.com/blog/)中搜索最新信息。

* * *

注意:这篇文章是系列文章的一部分。 [Part 2](/blog/are-we-autoscaling-yet/) 和 [Part 3](/blog/when-auto-scaling-build-fleets-work/) 现在也上线了，你可以[点击这里](https://goo.gl/forms/hq6sZEIiJ4)在本系列有新帖子加入时得到通知。

在过去的 5 年里，CircleCI 在我们快速增长的构建容器舰队上运行了数百万次构建。我们调整了许多参数，以使我们庞大的自动扩展服务器集群始终有能力运行构建，同时最大限度地减少未使用的资源。

## 一个新来的孩子

然而最近，在推出 circle ci Enterprise T1 之后，我们有很多客户询问我们如何在 AWS 自动扩展组或类似服务中运行他们自己的构建。自动缩放对他们有意义吗？哪些参数可以保持 CircleCI 实例的响应速度，同时最大限度地减少服务器的空闲时间？问题是，这些客户不希望一个有几千个容器的集群每小时处理来自全球分布的开发人员的几千个构建。他们想要几百个容器来每小时处理几十个开发者的构建。他们还使用不同的机器类型，不同的集装箱规格，与 circleci.com 有不同的运输模式。我们是运行单个巨型集群的专家，但现在我们需要学习成为运行数十个异构中型集群的顾问。思考这个问题让我想起了《心学数学》书架上的一本书，我突然想到，也许有一种方法可以用排队论来模拟这个问题。单个服务器运行在时间上随机发生的固定持续时间的作业(遵循泊松分布)的简单情况被称为 [M/D/1 队列](https://en.wikipedia.org/wiki/M/D/1_queue)，并且在这样的队列中有简单的期望等待时间的封闭形式的解决方案。多服务器(M/D/c)的情况有更复杂的封闭形式的解决方案，但是快速添加自动伸缩使问题变得棘手。或者至少我在几分钟的激烈搜索后没有找到答案，这实际上是一样的。

## 实验方法

在这里，我可以建立一些自动缩放的精细计算模拟，建立集群，用成千上万的可能参数运行蒙特卡罗实验的数百万次迭代，所以这当然就是我所做的。它位于 [bellkev/asg-sim](https://github.com/bellkev/asg-sim) ，我将在本文的剩余部分使用该模型的数据。我还应该在这里指出，虽然我关注的是在 [CircleCI Enterprise](/enterprise/) 中使用的构建集群建模，但我所涉及的大部分内容也将适用于在 circleci.com 上选择计划规模，甚至管理运行任意作业的服务器集群。

在讨论自动扩展之前，我花了一点时间讨论固定车队规模的情况，因为这是所有自动扩展解决方案的比较基础。在验证了我的模型与简单的 M/D/1 情况的理论预测相匹配之后，我开始研究平衡排队时间和资源利用的问题。只做好其中一件事，显然很容易。您可以供应不足并保持队列满且机器忙，也可以供应过度并保持队列空且机器空闲。下图清楚地说明了这一点。

![queue time vs utilitzation](img/fb46cd095fc0bd2425d01a4e1a5a248c.png)

此图显示了在不同大小的固定大小集群上运行相同流量模式时的情况。显然，较小的集群具有较高的机器利用率和较长的排队时间，而较大的集群具有较低的利用率和较短的排队时间。

## 成本函数

为了选择某种平衡点，我们需要做一点数学计算。开发人员的时间是宝贵的，所以他们在队列中等待构建的时间应该有某种价值。大型服务器也很昂贵，而且维持它们的运行也需要成本。您可以对总成本建模，如下所示:

```
cost = idle machine hours × cost per machine hour +
       queued build hours × cost per developer hour 
```

你可能在哲学上反对将人的工作时间等同于机器的工作时间，或者你可能会认为等待一个构建五分钟实际上会导致 30 分钟的生产力损失，因为这会导致中断。您甚至可能认为排队时间并不重要，因为开发人员可以在他们的构建运行时去喝咖啡或开发一些其他功能或其他东西。我认为这是荒谬的，因为如果开发人员在每次推进 CI 后都不得不进行任意长时间的休息或上下文切换，那么你在鼓励什么样的不可测量的坏结果呢？我们只需要将成本参数精确到十倍左右，所以不用太担心。我将使用每小时 200 美元(可能有点高，但中断是昂贵的)的开发人员时间和 AWS m4。除非另有说明，机器时间的大量点播率。

在我们继续之前值得指出的最后一点是，无论如何，缓慢的构建仍然是一样糟糕的。使用上面的参数，实际运行构建的成本如下所示:

```
build running cost = build run time ×
                     (cost per machine hour + cost per developer hour) 
```

显然这是很糟糕的，因为它占用了计算资源和开发人员的时间，但这个数字只取决于构建运行时间、构建数量和其他成本参数。您应该尽最大努力降低这一成本，但这与优化配置不足/过度配置构建集群的浪费成本是另一个问题。

## 计算数字

好了，现在我们已经为我们的模型定义了一个合理的成本函数，我们可以从成本曲线的角度来看之前的车队规模实验。(美元数额基本上是任意的。它们很大，因为我用数百台服务器为每个数据点运行了相当于几个月的模拟，以使图形漂亮而平滑。)

![cost curve](img/8420512829219fb3572c53918cd0584f.png)

这条曲线显然是不对称的，但如果你仔细想想，这是有道理的。在排队论中，队列增加的速度超过它处理作业的速度被认为是“不稳定的”,并且会迅速增长到无穷大。即使是稳定的队列也会由于流量的随机峰值而偶尔增长一点，导致一些平均队列长度，但是当系统接近不稳定极限时，该平均队列长度会逐渐增大。在曲线的另一端，随着我们向车队中添加建筑机械，成本会出现简单的线性增长。

如果我们为各种流量模式绘制其中一条曲线，我们就可以通过取最小值来得出这些工作负载的最佳车队规模。这是我们在不同频率下触发的 5 分钟构建的结果。

![cost vs. build time](img/76cababf825f7d2d5924bc0474ddb037.png)

现在我们已经有了成本方面的最佳车队规模，让我们看看对于固定规模的车队，什么样的排队时间和机器利用率水平被认为是最佳的。

![optimum properties by traffic](img/b7aaf75bd259b7f5a639b51d1c6b7e3f.png)

看那个！排队时间几乎为零，即使对于较小的车队规模，这需要将机器的利用率保持在 20%以下。请记住，即使在我们将开发人员视为机器中简单的、可交换的、固定价格的齿轮的模型中也是如此。保持较低的排队时间显然是值得的。还要注意，随着流量和车队规模的增长，您会获得一些规模经济。

如果我们以每小时固定的构建次数来看不同的构建时间，情况是相似的。

![optimum properties by build time](img/2ee6ee96d55427d1a13caa8ac50c60bb.png)

只是这一次，对于较慢的构建，我们获得了更高的利用率。这是缓慢构建的乌云周围的一线希望，但显然不是努力的目标。

## 这是真的吗？

到目前为止，对这一结论肯定有合理的可能的反对意见。例如，一个团队在昂贵的硬件上运行构建，生活在开发人员稍微便宜的经济环境中，并且不认为等待构建是“那么糟糕”呢？即使我的假设相差几个数量级，每次构建都需要相当于两台 m 4.10 x 大型机器的按需价格，并且开发人员赚取饥饿工资，结果几乎是一样的:

![optimum properties by developer cost](img/26399e501085f6fda71b58d86abe4e87.png)

即使有超级昂贵的硬件，让构建排队超过 10 秒钟也是不划算的，除非开发人员每小时赚 10 美元。让构建排队超过一分钟就相当于把开发人员的时间估价为每小时不到一美元，而让构建排队超过十分钟只有在开发人员每小时赚几分钱的情况下才有意义。

> 让构建排队超过一分钟就像把你的开发人员的时间估价为每小时不到一美元。”

我的理论是，为什么这种排队仍然很常见，是因为大多数组织没有将他们构建基础设施的成本与他们开发人员的成本放在一起考虑。相反，建造机器很可能是一项支出，一些团队领导受到激励来减少这一支出，而工资则更加不透明，由更高的层面决定。由于排队构建造成的生产力损失很难测量或量化，所以它被掩盖起来，成为懒惰、抱怨的开发人员的又一个借口。

## 结论

幸运的是，迄今为止的实验结果可以归结为一些非常简单的建议。如果您需要决定将固定大小的构建集群(或 circleci.com 计划，在逻辑上是等价的)设置为多大，那么将它设置为导致零排队的任何大小。当我说零时，这意味着对于大多数工作负载来说平均不到一秒，即使您在昂贵的硬件(或 circleci.com 上的高并行性)上运行构建，平均也不到 10 秒。随着流量(或构建运行时间)的增加，您将享受到更高的机器利用率，但您不应该为此担心。总是以接近零的排队时间为目标。

我还应该强调，这个模拟确实假设构建之间的时间是随机的，不受队列时间本身的影响。在长期排队构建的团队中，当队列很长时，开发人员避免推送或跳过 CI 可能是很常见的。但是，这种行为是你希望在你的团队中发生的吗？大概不会！

等等，自动缩放怎么样？难道不是应该力挽狂澜，让我们实现网络规模吗？嗯，我的手指现在已经厌倦了写博客，所以我将不得不把所有激动人心的数据留到下一期。敬请期待！

注意:这篇文章是系列文章的一部分。 [Part 2](/blog/are-we-autoscaling-yet/) 和 [Part 3](/blog/when-auto-scaling-build-fleets-work/) 现在也上线了，你可以[点击这里](https://goo.gl/forms/hq6sZEIiJ4)在本系列有新帖子加入时得到通知。